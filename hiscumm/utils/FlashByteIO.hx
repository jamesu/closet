package utils;
/*
hiscumm
-----------
Copyright (C) 2008 James S Urquhart (jamesu at gmail.com)
This program is free software; you can redistribute it and/ormodify it under the terms of the GNU General Public Licenseas published by the Free Software Foundation; either version 2of the License, or (at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program; if not, write to the Free SoftwareFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#if flash9

import flash.utils.ByteArray;
import flash.utils.Endian;
import noneko.Input;
import noneko.Output;
import noneko.Error;
import noneko.IOTools;
import utils.Seekable;

// NOTE: flash 9 Strings are supposedly NULL-terminated, but it is still possible
// to access the full string and its full length even if there is a '\0' stuck in the middle
// (generated by StringBuffer)

class FlashByteIO implements Input, implements Output, implements Seekable
{
	public var byteArray : ByteArray;
	
	public function new(?arr: ByteArray)
	{
		if (arr == null)
		{
			byteArray = new ByteArray();
		}
		else
		{
			byteArray = arr;
		}
	}
	
	public function close() : Void
	{
		byteArray = null;
	}
	
	// Input
	
	public function read(nbytes : Int) : String
	{
		return byteArray.readUTFBytes(nbytes);
	}
	
	public function readAll(?bufsize : Int) : String
	{
		return byteArray.readUTFBytes(byteArray.length);
	}
	
	public function readUntil(end : Int) : String
	{
		return IOTools.readUntil(this, end);
	}
	
	public function readBytes(s : String, p : Int, len : Int) : Int
	{
		// TODO: find equivalent
		return 0;
	}
	
	public function readFullBytes(s : String, pos : Int, len : Int) : Void
	{
		return IOTools.readFullBytes(this, s, pos, len);
	}
	
	public function readChar() : Int
	{
		return byteArray.readUnsignedByte();
	}
	
	public function readDouble() : Float
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return byteArray.readDouble();
	}
	
	public function readDoubleB() : Float
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		return byteArray.readDouble();
	}
	
	public function readFloat() : Float
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return byteArray.readFloat();
	}
	
	public function readFloatB() : Float
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		return byteArray.readFloat();
	}
	
	public function readInt16() : Int
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return byteArray.readShort();
	}
	
	public function readInt24() : Int
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return IOTools.readInt24(this);
	}
	
	public function readInt32() : Int
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return byteArray.readInt();
	}
	
	public function readInt8() : Int
	{
		return byteArray.readByte();
	}
	
	public function readUInt16() : Int
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return byteArray.readUnsignedShort();
	}
	
	public function readUInt16B() : Int
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		return byteArray.readUnsignedShort();
	}
	
	
	public function readUInt24() : Int
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return IOTools.readUInt24(this);
	}
	
	public function readUInt24B() : Int
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		return IOTools.readUInt24B(this);
	}
	
	public function readUInt32() : Int
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return byteArray.readUnsignedInt();
	}
	
	public function readUInt32B() : Int
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		return byteArray.readUnsignedInt();
	}
	
	public function readLine() : String
	{
		return IOTools.readLine(this);
	}
	
	// Output
	
	public function prepare(nbytes : Int) : Void
	{
		byteArray.length = nbytes;
	}
	
	public function flush() : Void
	{
	}
	
	public function write(s : String) : Void
	{
		byteArray.writeUTFBytes(s);
	}
	
	public function writeBytes(s : String, p : Int, len : Int) : Int
	{
		var opos: Int = byteArray.position;
		
		try
		{
			byteArray.writeUTFBytes(s.substr(p, len));
		}
		catch (e: Dynamic)
		{
			return 0;
		}
			
		return byteArray.position - opos;
	}
	
	public function writeChar(c : Int) : Void
	{
		byteArray.writeByte(c);
	}
	
	public function writeDouble(c : Float) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		byteArray.writeDouble(c);
	}
	
	public function writeDoubleB(c : Float) : Void
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		byteArray.writeDouble(c);
	}
	
	public function writeFloat(c : Float) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		byteArray.writeFloat(c);
	}
	
	public function writeFloatB(c : Float) : Void
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		byteArray.writeFloat(c);
	}
	
	public function writeFullBytes(s : String, pos : Int, len : Int) : Void
	{
		byteArray.writeUTFBytes(s.substr(pos, len));
	}
	
	public function writeInput(i : Input, ?bufsize : Int) : Void
	{
		var in_flashio = cast(i, FlashByteIO);
		
		if (in_flashio != null)
		{
			// Shortcut
			var leftbytes: Int = byteArray.bytesAvailable > in_flashio.byteArray.bytesAvailable ? 
			                                              in_flashio.byteArray.bytesAvailable :
			                                              byteArray.bytesAvailable;
			byteArray.writeBytes(in_flashio.byteArray, in_flashio.byteArray.position, leftbytes);
			
			in_flashio.byteArray.position += leftbytes;
		}
		else
		{
			// Errk... the long way around!
			try
			{
				while (byteArray.bytesAvailable != 0)
					byteArray.writeByte(i.readChar());
			}
			catch (e: Dynamic)
			{
				return;
			}
			throw Error.Blocked;
		}
	}
	
	public function writeInt16(x : Int) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		byteArray.writeShort(x);
	}
	
	public function writeInt24(x : Int) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		IOTools.writeInt24(this, x);
	}
	
	public function writeInt32(x : Int) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		byteArray.writeInt(x);
	}
	
	public function writeInt8(c : Int) : Void
	{
		byteArray.writeByte(c);
	}
	
	public function writeUInt16(x : Int) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		if( x < 0 || x > 0xFFFF ) throw Error.Overflow;
		writeChar(x & 0xFF);
		writeChar(x >> 8);
	}
	
	public function writeUInt16B(x : Int) : Void
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		if( x < 0 || x > 0xFFFF ) throw Error.Overflow;
		writeChar(x & 0xFF);
		writeChar(x >> 8);
	}
	
	public function writeUInt24(x : Int) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		return IOTools.writeUInt24(this, x);
	}
	
	public function writeUInt24B(x : Int) : Void
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		return IOTools.writeUInt24B(this, x);
	}
	
	public function writeUInt32(x : Int) : Void
	{
		byteArray.endian = Endian.LITTLE_ENDIAN;
		byteArray.writeUnsignedInt(x);
	}
	
	public function writeUInt32B(x : Int) : Void
	{
		byteArray.endian = Endian.BIG_ENDIAN;
		byteArray.writeUnsignedInt(x);
	}

	// Seekable IO
	
	public function seek(p : Int, pos : Seek) : Void
	{
		switch (pos)
		{
			case SeekEnd:
				byteArray.position = byteArray.length - p;
			case SeekCur:
				byteArray.position += p;
			case SeekBegin:
				byteArray.position = p;
		}
	}
	
	public function tell() : Int
	{
		return byteArray.position;
	}
}

#end
